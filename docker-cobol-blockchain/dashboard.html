<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>COBOL-Blockchain Integration Dashboard</title>
				<style>
					* {
					margin: 0;
					padding: 0;
					box-sizing: border-box;
					}

					body {
					font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
					background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
					color: #333;
					min-height: 100vh;
					padding: 20px;
					}

					.container {
					max-width: 1400px;
					margin: 0 auto;
					}

					.header {
					background: rgba(255, 255, 255, 0.95);
					padding: 20px 30px;
					border-radius: 15px;
					box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
					margin-bottom: 30px;
					backdrop-filter: blur(10px);
					}

					.header h1 {
					color: #1e3c72;
					font-size: 2.2em;
					margin-bottom: 8px;
					}

					.header p {
					color: #666;
					font-size: 1em;
					}

					.status-bar {
					display: flex;
					gap: 15px;
					margin-top: 15px;
					flex-wrap: wrap;
					}

					.status-item {
					background: #f8f9fa;
					padding: 12px 20px;
					border-radius: 8px;
					flex: 1;
					min-width: 160px;
					text-align: center;
					transition: transform 0.3s ease;
					border: 2px solid transparent;
					}

					.status-item:hover {
					transform: translateY(-2px);
					}

					.status-item.active {
					background: #e8f5e8;
					border-color: #4CAF50;
					color: #2e7d32;
					}

					.status-item.inactive {
					background: #ffebee;
					border-color: #f44336;
					color: #c62828;
					}

					.status-item.warning {
					background: #fff3e0;
					border-color: #ff9800;
					color: #f57c00;
					}

					.status-item strong {
					display: block;
					font-size: 0.9em;
					margin-bottom: 4px;
					text-transform: uppercase;
					letter-spacing: 1px;
					}

					.status-item span {
					font-size: 1.1em;
					font-weight: 600;
					}

					.controls {
					background: rgba(255, 255, 255, 0.95);
					padding: 20px;
					border-radius: 15px;
					margin-bottom: 20px;
					display: flex;
					gap: 15px;
					align-items: center;
					flex-wrap: wrap;
					backdrop-filter: blur(10px);
					}

					.btn {
					background: linear-gradient(135deg, #1e3c72, #2a5298);
					color: white;
					border: none;
					padding: 12px 24px;
					border-radius: 8px;
					cursor: pointer;
					font-weight: 600;
					transition: all 0.3s ease;
					text-decoration: none;
					display: inline-flex;
					align-items: center;
					gap: 8px;
					}

					.btn:hover {
					transform: translateY(-2px);
					box-shadow: 0 8px 25px rgba(30, 60, 114, 0.3);
					}

					.btn.secondary {
					background: linear-gradient(135deg, #6c757d, #5a6268);
					}

					.filter-input {
					padding: 12px 16px;
					border: 2px solid #e0e0e0;
					border-radius: 8px;
					font-size: 14px;
					width: 300px;
					transition: border-color 0.3s ease;
					}

					.filter-input:focus {
					outline: none;
					border-color: #1e3c72;
					}

					.stats-section {
					margin-bottom: 30px;
					}

					.stats-grid {
					display: grid;
					grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
					gap: 20px;
					}

					.stat-card {
					background: rgba(255, 255, 255, 0.95);
					padding: 25px;
					border-radius: 15px;
					text-align: center;
					transition: transform 0.3s ease, box-shadow 0.3s ease;
					backdrop-filter: blur(10px);
					}

					.stat-card:hover {
					transform: translateY(-5px);
					box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
					}

					.stat-number {
					font-size: 2.5em;
					font-weight: 700;
					color: #1e3c72;
					margin-bottom: 8px;
					}

					.stat-label {
					color: #666;
					font-size: 0.95em;
					text-transform: uppercase;
					letter-spacing: 1px;
					}

					.table-section {
					background: rgba(255, 255, 255, 0.95);
					border-radius: 15px;
					overflow: hidden;
					backdrop-filter: blur(10px);
					}

					.tab-container {
					border-bottom: 1px solid #e0e0e0;
					}

					.tab-nav {
					display: flex;
					background: #f8f9fa;
					}

					.tab-button {
					flex: 1;
					padding: 15px 25px;
					border: none;
					background: none;
					cursor: pointer;
					font-weight: 600;
					color: #666;
					transition: all 0.3s ease;
					border-bottom: 3px solid transparent;
					}

					.tab-button:hover {
					background: rgba(30, 60, 114, 0.1);
					color: #1e3c72;
					}

					.tab-button.active {
					background: white;
					color: #1e3c72;
					border-bottom-color: #1e3c72;
					}

					.tab-content {
					padding: 0;
					}

					.tab-pane {
					display: none;
					min-height: 400px;
					}

					.tab-pane.active {
					display: block;
					}

					.data-table {
					width: 100%;
					border-collapse: collapse;
					}

					.data-table th {
					background: #f8f9fa;
					padding: 15px;
					text-align: left;
					font-weight: 600;
					color: #333;
					border-bottom: 2px solid #dee2e6;
					}

					.data-table td {
					padding: 15px;
					border-bottom: 1px solid #e9ecef;
					vertical-align: middle;
					}

					.data-table tr:hover {
					background: rgba(30, 60, 114, 0.05);
					}

					.pagination {
					display: flex;
					justify-content: space-between;
					align-items: center;
					padding: 20px;
					background: #f8f9fa;
					border-top: 1px solid #e0e0e0;
					}

					.pagination-controls {
					display: flex;
					gap: 10px;
					align-items: center;
					}

					.page-btn {
					padding: 8px 16px;
					border: 1px solid #dee2e6;
					background: white;
					color: #6c757d;
					border-radius: 4px;
					cursor: pointer;
					transition: all 0.3s ease;
					}

					.page-btn:hover:not(:disabled) {
					background: #1e3c72;
					color: white;
					border-color: #1e3c72;
					}

					.page-btn:disabled {
					opacity: 0.5;
					cursor: not-allowed;
					}

					.page-numbers {
					display: flex;
					gap: 5px;
					}

					.page-number {
					padding: 8px 12px;
					border: 1px solid #dee2e6;
					background: white;
					color: #6c757d;
					border-radius: 4px;
					cursor: pointer;
					transition: all 0.3s ease;
					}

					.page-number.active {
					background: #1e3c72;
					color: white;
					border-color: #1e3c72;
					}

					.page-number:hover:not(.active) {
					background: #f8f9fa;
					}

					.loading {
					text-align: center;
					padding: 60px;
					color: #999;
					font-size: 1.1em;
					}

					.loading::after {
					content: '';
					animation: loading-dots 1.5s infinite;
					}

					@keyframes loading-dots {
					0%, 20% { content: '.'; }
					40% { content: '..'; }
					60% { content: '..'; }
					80%, 100% { content: '...'; }
					}

					.no-data {
					text-align: center;
					padding: 40px;
					color: #999;
					font-style: italic;
					}

					.refresh-indicator {
					display: inline-block;
					animation: spin 2s linear infinite;
					opacity: 0;
					transition: opacity 0.3s ease;
					}

					.refresh-indicator.active {
					opacity: 1;
					}

					@keyframes spin {
					from { transform: rotate(0deg); }
					to { transform: rotate(360deg); }
					}

					.operation-badge {
					padding: 4px 8px;
					border-radius: 4px;
					font-size: 0.75em;
					font-weight: 600;
					background: #e3f2fd;
					color: #1976d2;
					}

					.status-badge {
					padding: 4px 8px;
					border-radius: 4px;
					font-size: 0.75em;
					font-weight: 600;
					}

					.status-badge.confirmed {
					background: #e8f5e8;
					color: #2e7d32;
					}

					.status-badge.pending {
					background: #fff3e0;
					color: #f57c00;
					}

					.error-message {
					background: #ffebee;
					color: #c62828;
					padding: 15px;
					border-radius: 8px;
					margin: 20px;
					border-left: 4px solid #f44336;
					}

					.connection-status {
					position: fixed;
					top: 20px;
					right: 20px;
					padding: 10px 15px;
					border-radius: 8px;
					font-size: 0.9em;
					font-weight: 600;
					z-index: 1000;
					}

					.connection-status.connected {
					background: #e8f5e8;
					color: #2e7d32;
					border: 1px solid #4CAF50;
					}

					.connection-status.disconnected {
					background: #ffebee;
					color: #c62828;
					border: 1px solid #f44336;
					}

					@media (max-width: 768px) {
					.container {
					padding: 10px;
					}

					.header {
					padding: 15px 20px;
					}

					.header h1 {
					font-size: 1.8em;
					}

					.stats-grid {
					grid-template-columns: repeat(2, 1fr);
					}

					.controls {
					flex-direction: column;
					align-items: stretch;
					}

					.tab-nav {
					flex-direction: column;
					}
					}
				</style>
			</head>
	<body>
		<div class="connection-status" id="connection-status">
			🔴 Disconnected
		</div>

		<div class="container">
			<div class="header">
				<h1>COBOL-Blockchain Integration Dashboard</h1>
				<p>Real-time monitoring of legacy COBOL systems integrated with Hyperledger Fabric</p>

				<div class="status-bar">
					<div class="status-item inactive" id="cobol-status">
						<strong>COBOL System</strong>
						<span>Unknown</span>
					</div>
					<div class="status-item inactive" id="blockchain-status">
						<strong>Blockchain</strong>
						<span>Unknown</span>
					</div>
					<div class="status-item inactive" id="adapter-status">
						<strong>Adapter</strong>
						<span>Unknown</span>
					</div>
					<div class="status-item" id="last-sync">
						<strong>Last Sync</strong>
						<span id="sync-time">Never</span>
					</div>
				</div>
			</div>

			<div class="controls">
				<button class="btn" onclick="refreshData()">
					Refresh Data
					<span class="refresh-indicator" id="refresh-indicator">⟳</span>
				</button>
				<button class="btn secondary" onclick="clearFilters()">Clear Filters</button>
				<input type="text" class="filter-input" id="filter-input" placeholder="Filter by record ID or file name...">
					<button class="btn" onclick="simulateTransaction()">Simulate Transaction</button>
					<button class="btn secondary" onclick="changeAPIUrl()">Change API URL</button>
					<button class="btn secondary" onclick="exportData()">Export Data</button>
					<button class="btn secondary" onclick="showDebugInfo()">Debug Info</button>
				</div>

			<!-- Statistics Section -->
			<div class="stats-section">
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-number" id="total-transactions">0</div>
						<div class="stat-label">Total Transactions</div>
					</div>
					<div class="stat-card">
						<div class="stat-number" id="total-blocks">0</div>
						<div class="stat-label">Total Blocks</div>
					</div>
					<div class="stat-card">
						<div class="stat-number" id="active-files">0</div>
						<div class="stat-label">Active Files</div>
					</div>
					<div class="stat-card">
						<div class="stat-number" id="pending-ops">0</div>
						<div class="stat-label">Pending Operations</div>
					</div>
					<div class="stat-card">
						<div class="stat-number" id="error-count">0</div>
						<div class="stat-label">Errors (24h)</div>
					</div>
					<div class="stat-card">
						<div class="stat-number" id="throughput">0</div>
						<div class="stat-label">Ops/Min</div>
					</div>
				</div>
			</div>

			<!-- Tabbed Table Section -->
			<div class="table-section">
				<div class="tab-container">
					<div class="tab-nav">
						<button class="tab-button active" onclick="switchTab('transactions')">
							Recent Transactions
						</button>
						<button class="tab-button" onclick="switchTab('blocks')">
							Blockchain Blocks
						</button>
					</div>
				</div>

				<div class="tab-content">
					<!-- Transactions Tab -->
					<div id="transactions-tab" class="tab-pane active">
						<div class="loading" id="transactions-loading">Loading transactions</div>
						<div id="transactions-data" style="display: none;">
							<table class="data-table">
								<thead>
									<tr>
										<th>Transaction ID</th>
										<th>Operation</th>
										<th>Entity</th>
										<th>Source File</th>
										<th>Timestamp</th>
										<th>Status</th>
									</tr>
								</thead>
								<tbody id="transactions-tbody">
									<!-- Dynamic content -->
								</tbody>
							</table>
							<div class="pagination">
								<div class="pagination-info" id="transactions-info">
									Showing 0-0 of 0 transactions
								</div>
								<div class="pagination-controls">
									<button class="page-btn" id="trans-prev" onclick="previousPage('transactions')" disabled="">
										← Previous
									</button>
									<span id="trans-page-numbers"></span>
									<button class="page-btn" id="trans-next" onclick="nextPage('transactions')">
										Next →
									</button>
								</div>
							</div>
						</div>
						<div id="transactions-no-data" class="no-data" style="display: none;">
							No transactions found
						</div>
						<div id="transactions-error" class="error-message" style="display: none;">
							<strong>Error loading transactions:</strong>
							<span id="transactions-error-text"></span>
						</div>
					</div>

					<!-- Blocks Tab -->
					<div id="blocks-tab" class="tab-pane">
						<div class="loading" id="blocks-loading">Loading blocks</div>
						<div id="blocks-data" style="display: none;">
							<table class="data-table">
								<thead>
									<tr>
										<th>Block Number</th>
										<th>Hash</th>
										<th>Previous Hash</th>
										<th>Transactions</th>
										<th>Timestamp</th>
										<th>Size</th>
									</tr>
								</thead>
								<tbody id="blocks-tbody">
									<!-- Dynamic content -->
								</tbody>
							</table>
							<div class="pagination">
								<div class="pagination-info" id="blocks-info">
									Showing 0-0 of 0 blocks
								</div>
								<div class="pagination-controls">
									<button class="page-btn" id="blocks-prev" onclick="previousPage('blocks')" disabled="">
										← Previous
									</button>
									<span id="blocks-page-numbers"></span>
									<button class="page-btn" id="blocks-next" onclick="nextPage('blocks')">
										Next →
									</button>
								</div>
							</div>
						</div>
						<div id="blocks-no-data" class="no-data" style="display: none;">
							No blocks found
						</div>
						<div id="blocks-error" class="error-message" style="display: none;">
							<strong>Error loading blocks:</strong>
							<span id="blocks-error-text"></span>
						</div>
					</div>
				</div>
			</div>
		</div>

		<script>
			// Global state
			let currentTab = 'transactions';
			let currentPage = { transactions: 1, blocks: 1 };
			let pageSize = 10;
			let totalPages = { transactions: 1, blocks: 1 };
			let allData = { transactions: [], blocks: [] };
			let filteredData = { transactions: [], blocks: [] };

			// API configuration - FIXED for your GCP deployment
			let API_BASE_URL = 'http://34.63.80.75:8080'; // Your VM IP from connection-info.txt
			const API_ENDPOINTS = {
			status: '/status',
			transactions: '/transactions', // FIXED: No /api prefix for GCP endpoints
			blocks: '/blocks',           // FIXED: No /api prefix for GCP endpoints
			health: '/health',
			debug: '/debug'
			};

			// Initialize dashboard
			document.addEventListener('DOMContentLoaded', function() {
			// Try to load API URL from localStorage
			const savedUrl = localStorage.getItem('apiBaseUrl');
			if (savedUrl) {
			API_BASE_URL = savedUrl;
			}

			refreshData();
			checkSystemStatus();
			setInterval(refreshData, 30000); // Auto-refresh every 30 seconds
			setInterval(checkSystemStatus, 60000); // Check status every minute
			});

			// FIXED: Fetch data from API with proper error handling
			async function fetchData(endpoint) {
			try {
			console.log(`Fetching: ${API_BASE_URL}${endpoint}`);
			const response = await fetch(API_BASE_URL + endpoint, {
			method: 'GET',
			headers: {
			'Accept': 'application/json',
			'Content-Type': 'application/json'
			},
			timeout: 10000
			});

			if (!response.ok) {
			throw new Error(`HTTP error! status: ${response.status}`);
			}

			const data = await response.json();
			console.log(`Data from ${endpoint}:`, data);
			return data;
			} catch (error) {
			console.error(`Error fetching ${endpoint}:`, error);
			updateConnectionStatus(false);
			return null;
			}
			}

			// FIXED: Load transactions with historical data from blocks + pending
			async function loadTransactions() {
			try {
			showError('transactions', null);

			// Get both blocks and pending transactions
			const [blocksData, pendingData] = await Promise.all([
			fetchData(API_ENDPOINTS.blocks),
			fetchData(API_ENDPOINTS.transactions)
			]);

			console.log('Blocks data:', blocksData);
			console.log('Pending data:', pendingData);

			let allTransactions = [];

			// Extract historical transactions from blocks
			if (blocksData && blocksData.blocks && Array.isArray(blocksData.blocks)) {
			blocksData.blocks.forEach(block => {
			if (block.transactions && Array.isArray(block.transactions)) {
			block.transactions.forEach(tx => {
			const txData = tx.data || {};
			allTransactions.push({
			id: tx.id || 'Unknown',
			operation: txData.operation || 'Unknown',
			entity: txData.entity || 'Unknown',
			file: txData.source || txData.file || 'Unknown',
			timestamp: tx.timestamp || block.timestamp || new Date().toISOString(),
			status: 'Confirmed', // Historical transactions are confirmed
			block_number: block.number || block.index,
			message_number: tx.message_number || ''
			});
			});
			}
			});
			}

			// Add pending transactions
			if (pendingData && pendingData.pending_transactions && Array.isArray(pendingData.pending_transactions)) {
			pendingData.pending_transactions.forEach(tx => {
			const txData = tx.data || {};
			allTransactions.push({
			id: tx.id || tx.pubsub_message_id || 'Unknown',
			operation: txData.operation || 'Unknown',
			entity: txData.entity || 'Unknown',
			file: txData.source || txData.file || 'Unknown',
			timestamp: tx.timestamp || new Date().toISOString(),
			status: 'Pending',
			block_number: null,
			message_number: tx.message_number || ''
			});
			});
			}

			// Sort by timestamp (newest first)
			allTransactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

			console.log('Total transactions loaded:', allTransactions.length);

			allData.transactions = allTransactions;
			filteredData.transactions = [...allTransactions];

			} catch (error) {
			console.error('Error in loadTransactions:', error);
			allData.transactions = [];
			filteredData.transactions = [];
			showError('transactions', error.message);
			}
			}

			// FIXED: Load blocks with pagination support (request all blocks)
			async function loadBlocks() {
			try {
			showError('blocks', null);

			// Try to get more blocks by checking if there's a way to get all blocks
			const data = await fetchData(API_ENDPOINTS.blocks);
			console.log('Raw blocks data:', data);

			if (data) {
			let blocks = [];

			if (data.blocks && Array.isArray(data.blocks)) {
			blocks = data.blocks.map(block => ({
			number: block.number || block.index || block.block_number || 'Unknown',
			hash: block.hash || 'Unknown',
			prevHash: block.previous_hash || block.prevHash || 'Unknown',
			transactions: block.transaction_count || (block.transactions ? block.transactions.length : 0),
			timestamp: block.timestamp || new Date().toISOString(),
			size: block.size || `${block.transaction_count || 0} txs`
			}));

			// Sort by block number (newest first)
			blocks.sort((a, b) => (parseInt(b.number) || 0) - (parseInt(a.number) || 0));
			}

			console.log('Total blocks loaded:', blocks.length);
			console.log('API shows total_blocks:', data.total_blocks);

			// Show warning if we're not getting all blocks
			if (data.total_blocks && blocks.length < data.total_blocks) {
                        console.warn(`⚠️ Only showing ${blocks.length} of ${data.total_blocks} blocks (API limitation)`);
                        showError('blocks', `Showing recent ${blocks.length} of ${data.total_blocks} total blocks (API limit)`);
                    }
                    
                    allData.blocks = blocks;
                    filteredData.blocks = [...blocks];
                } else {
                    allData.blocks = [];
                    filteredData.blocks = [];
                    showError('blocks', 'Failed to load block data');
                }
            } catch (error) {
                console.error('Error in loadBlocks:', error);
                allData.blocks = [];
                filteredData.blocks = [];
                showError('blocks', error.message);
            }
        }

        // FIXED: Load statistics with comprehensive data
        async function loadStatistics() {
            try {
                const statusData = await fetchData(API_ENDPOINTS.status);
                
                if (statusData) {
                    // Calculate actual totals from loaded data
                    const confirmedTransactions = allData.transactions.filter(tx => tx.status === 'Confirmed').length;
                    const pendingTransactions = allData.transactions.filter(tx => tx.status === 'Pending').length;
                    const uniqueFiles = new Set(allData.transactions.map(tx => tx.file)).size;
                    
                    updateStatistics({
                        totalTransactions: allData.transactions.length,
                        totalBlocks: statusData.blocks || allData.blocks.length,
                        filesMonitored: uniqueFiles,
                        successRate: confirmedTransactions > 0 ? Math.round((confirmedTransactions / allData.transactions.length) * 100) : 100,
                        pendingOps: pendingTransactions,
                        errorCount: 0
                    });
                } else {
                    // Use default values if API fails
                    updateStatistics({
                        totalTransactions: allData.transactions.length,
                        totalBlocks: allData.blocks.length,
                        filesMonitored: 0,
                        successRate: 0,
                        pendingOps: 0,
                        errorCount: 1 // Show that there's an API error
                    });
                }
            } catch (error) {
                console.error('Error loading statistics:', error);
                updateStatistics({
                    totalTransactions: allData.transactions.length,
                    totalBlocks: allData.blocks.length,
                    filesMonitored: 0,
                    successRate: 0,
                    pendingOps: 0,
                    errorCount: 1
                });
            }
        }

        // FIXED: System status checker with proper status mapping
        async function checkSystemStatus() {
            try {
                const data = await fetchData(API_ENDPOINTS.status);
                if (data) {
                    updateSystemStatus({
                        cobolSystem: 'active', // Assume active if API is responding
                        blockchain: 'connected',
                        adapter: 'running',
                        lastSync: new Date().toISOString()
                    });
                    updateConnectionStatus(true);
                } else {
                    updateSystemStatus({
                        cobolSystem: 'inactive',
                        blockchain: 'disconnected', 
                        adapter: 'stopped',
                        lastSync: 'Never'
                    });
                    updateConnectionStatus(false);
                }
            } catch (error) {
                console.error('Error checking system status:', error);
                updateConnectionStatus(false);
            }
        }

        // FIXED: Added missing updateSystemStatus function
        function updateSystemStatus(status) {
            const cobolStatus = document.getElementById('cobol-status');
            const blockchainStatus = document.getElementById('blockchain-status');
            const adapterStatus = document.getElementById('adapter-status');
            const syncTime = document.getElementById('sync-time');

            if (cobolStatus) {
                cobolStatus.className = `status-item ${status.cobolSystem === 'active' ? 'active' : 'inactive'}`;
                cobolStatus.querySelector('span').textContent = status.cobolSystem === 'active' ? 'Active' : 'Inactive';
            }

            if (blockchainStatus) {
                blockchainStatus.className = `status-item ${status.blockchain === 'connected' ? 'active' : 'inactive'}`;
                blockchainStatus.querySelector('span').textContent = status.blockchain === 'connected' ? 'Connected' : 'Disconnected';
            }

            if (adapterStatus) {
                adapterStatus.className = `status-item ${status.adapter === 'running' ? 'active' : 'inactive'}`;
                adapterStatus.querySelector('span').textContent = status.adapter === 'running' ? 'Running' : 'Stopped';
            }

            if (syncTime && status.lastSync) {
			syncTime.textContent = status.lastSync === 'Never' ? 'Never' : formatDate(status.lastSync);
			}
			}

			// FIXED: Connection status indicator
			function updateConnectionStatus(connected) {
			const statusElement = document.getElementById('connection-status');
			if (connected) {
			statusElement.className = 'connection-status connected';
			statusElement.textContent = '🟢 Connected';
			} else {
			statusElement.className = 'connection-status disconnected';
			statusElement.textContent = '🔴 Disconnected';
			}
			}

			// Error display function
			function showError(tabName, errorMessage) {
			const errorDiv = document.getElementById(`${tabName}-error`);
			const errorText = document.getElementById(`${tabName}-error-text`);

			if (errorMessage) {
			errorText.textContent = errorMessage;
			errorDiv.style.display = 'block';
			} else {
			errorDiv.style.display = 'none';
			}
			}

			// Main refresh function
			async function refreshData() {
			const indicator = document.getElementById('refresh-indicator');
			indicator.classList.add('active');

			try {
			await Promise.all([
			loadTransactions(),
			loadBlocks(),
			loadStatistics()
			]);

			// Reset pagination
			currentPage.transactions = 1;
			currentPage.blocks = 1;

			renderTable(currentTab);
			} catch (error) {
			console.error('Error refreshing data:', error);
			} finally {
			indicator.classList.remove('active');
			}
			}

			function switchTab(tabName) {
			// Update tab buttons
			document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
			event.target.classList.add('active');

			// Update tab panes
			document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
			document.getElementById(tabName + '-tab').classList.add('active');

			currentTab = tabName;
			renderTable(tabName);
			}

			function renderTable(tabName) {
			const loading = document.getElementById(tabName + '-loading');
			const dataDiv = document.getElementById(tabName + '-data');
			const noDataDiv = document.getElementById(tabName + '-no-data');
			const tbody = document.getElementById(tabName + '-tbody');

			loading.style.display = 'block';
			dataDiv.style.display = 'none';
			noDataDiv.style.display = 'none';

			setTimeout(() => {
			const data = filteredData[tabName];

			if (!data || data.length === 0) {
			loading.style.display = 'none';
			noDataDiv.style.display = 'block';
			return;
			}

			// Calculate pagination
			totalPages[tabName] = Math.ceil(data.length / pageSize);
			const startIndex = (currentPage[tabName] - 1) * pageSize;
			const endIndex = Math.min(startIndex + pageSize, data.length);
			const pageData = data.slice(startIndex, endIndex);

			// Render table rows
			tbody.innerHTML = '';
			pageData.forEach(item => {
			const row = createTableRow(tabName, item);
			tbody.appendChild(row);
			});

			// Update pagination info
			updatePaginationInfo(tabName, startIndex, endIndex, data.length);
			updatePaginationControls(tabName);

			loading.style.display = 'none';
			dataDiv.style.display = 'block';
			}, 500);
			}

			function createTableRow(tabName, item) {
			const row = document.createElement('tr');

			if (tabName === 'transactions') {
			const statusClass = (item.status || 'pending').toLowerCase();
			const blockInfo = item.block_number ? `Block #${item.block_number}` : 'Pending';

			row.innerHTML = `
			<td title="${item.id}">${(item.id || 'Unknown').substring(0, 12)}${item.id && item.id.length > 12 ? '...' : ''}</td>
			<td>
				<span class="operation-badge">${item.operation || 'Unknown'}</span>
			</td>
			<td>${item.entity || 'Unknown'}</td>
			<td>${item.file || item.source || 'Unknown'}</td>
			<td title="${item.timestamp}">${formatDate(item.timestamp)}</td>
			<td>
				<span class="status-badge ${statusClass}" title="${blockInfo}">${item.status || 'Pending'}</span>
			</td>
			`;
			} else if (tabName === 'blocks') {
			row.innerHTML = `
			<td>${item.number || item.index || 'Unknown'}</td>
			<td title="${item.hash}">${(item.hash || 'Unknown').substring(0, 16)}${item.hash && item.hash.length > 16 ? '...' : ''}</td>
			<td title="${item.prevHash}">${(item.prevHash || 'Unknown').substring(0, 16)}${item.prevHash && item.prevHash.length > 16 ? '...' : ''}</td>
			<td>${item.transactions || 0}</td>
			<td title="${item.timestamp}">${formatDate(item.timestamp)}</td>
			<td>${item.size || 'Unknown'}</td>
			`;
			}

			return row;
			}

			function updatePaginationInfo(tabName, startIndex, endIndex, total) {
			const info = document.getElementById(tabName + '-info');
			info.textContent = `Showing ${startIndex + 1}-${endIndex} of ${total} ${tabName}`;
			}

			function updatePaginationControls(tabName) {
			const prevBtn = document.getElementById(tabName === 'transactions' ? 'trans-prev' : 'blocks-prev');
			const nextBtn = document.getElementById(tabName === 'transactions' ? 'trans-next' : 'blocks-next');
			const pageNumbers = document.getElementById(tabName === 'transactions' ? 'trans-page-numbers' : 'blocks-page-numbers');

			prevBtn.disabled = currentPage[tabName] <= 1;
			nextBtn.disabled = currentPage[tabName] >= totalPages[tabName];

			// Generate page numbers
			let numbersHtml = '';
			const maxVisiblePages = 5;
			let startPage = Math.max(1, currentPage[tabName] - Math.floor(maxVisiblePages / 2));
			let endPage = Math.min(totalPages[tabName], startPage + maxVisiblePages - 1);

			if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
			numbersHtml += `<span class="page-number ${i === currentPage[tabName] ? 'active' : ''}" onclick="goToPage('${tabName}', ${i})">${i}</span>`;
			}

			pageNumbers.innerHTML = numbersHtml;
			}

			function previousPage(tabName) {
			if (currentPage[tabName] > 1) {
			currentPage[tabName]--;
			renderTable(tabName);
			}
			}

			function nextPage(tabName) {
			if (currentPage[tabName] < totalPages[tabName]) {
                currentPage[tabName]++;
                renderTable(tabName);
            }
        }

        function goToPage(tabName, pageNumber) {
            currentPage[tabName] = pageNumber;
            renderTable(tabName);
        }

        function updateStatistics(stats) {
            document.getElementById('total-transactions').textContent = stats.totalTransactions || 0;
            document.getElementById('total-blocks').textContent = stats.totalBlocks || 0;
            document.getElementById('active-files').textContent = stats.filesMonitored || 0;
            document.getElementById('pending-ops').textContent = stats.pendingOps || 0;
            document.getElementById('error-count').textContent = stats.errorCount || 0;
            document.getElementById('throughput').textContent = stats.throughput || 0;
        }

        function simulateTransaction() {
            const newTransaction = {
                id: 'SIM_' + Date.now(),
                operation: 'CREATE',
                entity: 'SimulatedRecord',
                file: 'dashboard-test',
                timestamp: new Date().toISOString(),
                status: Math.random() > 0.3 ? 'Confirmed' : 'Pending'
            };

            allData.transactions.unshift(newTransaction);
            filteredData.transactions.unshift(newTransaction);
            
            if (currentTab === 'transactions') {
                renderTable('transactions');
            }
            updateStatistics({
                totalTransactions: allData.transactions.length,
                totalBlocks: allData.blocks.length,
                filesMonitored: 0,
                successRate: 95,
                pendingOps: 0,
                errorCount: 0
            });
        }

        function changeAPIUrl() {
            const newUrl = prompt('Enter new API URL (e.g., http://34.63.80.75:8080):', API_BASE_URL);
            if (newUrl && newUrl.trim()) {
			API_BASE_URL = newUrl.trim();
			localStorage.setItem('apiBaseUrl', API_BASE_URL);
			refreshData();
			checkSystemStatus();
			}
			}

			function clearFilters() {
			document.getElementById('filter-input').value = '';
			filteredData.transactions = [...allData.transactions];
			filteredData.blocks = [...allData.blocks];
			currentPage.transactions = 1;
			currentPage.blocks = 1;
			renderTable(currentTab);
			}

			function exportData() {
			const data = {
			transactions: allData.transactions,
			blocks: allData.blocks,
			exported_at: new Date().toISOString(),
			total_transactions: allData.transactions.length,
			total_blocks: allData.blocks.length
			};

			const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
			const url = window.URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `blockchain-data-${new Date().toISOString().split('T')[0]}.json`;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			window.URL.revokeObjectURL(url);
			}

			function showDebugInfo() {
			const debugInfo = {
			api_base_url: API_BASE_URL,
			total_transactions_loaded: allData.transactions.length,
			total_blocks_loaded: allData.blocks.length,
			confirmed_transactions: allData.transactions.filter(tx => tx.status === 'Confirmed').length,
			pending_transactions: allData.transactions.filter(tx => tx.status === 'Pending').length,
			unique_files: new Set(allData.transactions.map(tx => tx.file)).size,
			latest_transaction: allData.transactions[0],
			latest_block: allData.blocks[0],
			current_tab: currentTab,
			current_filter: document.getElementById('filter-input').value
			};

			console.log('=== DASHBOARD DEBUG INFO ===');
			console.log(JSON.stringify(debugInfo, null, 2));
			console.log('============================');

			alert(`Debug info logged to console.\n\nQuick Stats:\n• ${debugInfo.total_transactions_loaded} transactions loaded\n• ${debugInfo.total_blocks_loaded} blocks loaded\n• ${debugInfo.confirmed_transactions} confirmed, ${debugInfo.pending_transactions} pending\n• ${debugInfo.unique_files} unique files`);
			}

			function formatDate(dateString) {
			try {
			const date = new Date(dateString);
			return date.toLocaleString();
			} catch (error) {
			return dateString || 'Unknown';
			}
			}

			// Filter functionality
			document.getElementById('filter-input').addEventListener('input', function(e) {
			const filter = e.target.value.toLowerCase();

			filteredData.transactions = allData.transactions.filter(item =>
			(item.id || '').toLowerCase().includes(filter) ||
			(item.operation || '').toLowerCase().includes(filter) ||
			(item.entity || '').toLowerCase().includes(filter) ||
			(item.file || '').toLowerCase().includes(filter)
			);

			filteredData.blocks = allData.blocks.filter(item =>
			(item.number || '').toString().includes(filter) ||
			(item.hash || '').toLowerCase().includes(filter)
			);

			currentPage.transactions = 1;
			currentPage.blocks = 1;
			renderTable(currentTab);
			});

			// Debug function
			function debugData() {
			console.log('=== DEBUG INFO ===');
			console.log('API Base URL:', API_BASE_URL);
			console.log('All transactions data:', allData.transactions);
			console.log('All blocks data:', allData.blocks);
			console.log('Filtered transactions data:', filteredData.transactions);
			console.log('Filtered blocks data:', filteredData.blocks);
			console.log('Current tab:', currentTab);
			console.log('==================');
			}

			// Make debug function available globally
			window.debugData = debugData;
		</script>
	</body>
</html>