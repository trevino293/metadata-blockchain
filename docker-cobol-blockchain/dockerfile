# Multi-stage Dockerfile that includes Fabric tools for crypto generation
FROM hyperledger/fabric-tools:2.5 AS fabric-tools

# Copy the binaries we need
RUN cp /usr/local/bin/cryptogen /tmp/ && \
    cp /usr/local/bin/configtxgen /tmp/

# Main application stage
FROM ubuntu:20.04

ENV DEBIAN_FRONTEND=noninteractive

# Install dependencies
RUN apt-get update && apt-get install -y \
    gnucobol \
    python3 \
    python3-pip \
    curl \
    jq \
    && rm -rf /var/lib/apt/lists/*

# Copy Fabric tools from previous stage
COPY --from=fabric-tools /tmp/cryptogen /usr/local/bin/
COPY --from=fabric-tools /tmp/configtxgen /usr/local/bin/
RUN chmod +x /usr/local/bin/cryptogen /usr/local/bin/configtxgen

# Install Python packages
RUN pip3 install flask requests

WORKDIR /app

# Create directories
RUN mkdir -p data logs scripts

# Create the setup script
COPY <<EOF /app/scripts/setup-crypto.sh
#!/bin/bash
set -e

echo "Checking if crypto materials exist..."
if [ ! -d "/crypto-config/ordererOrganizations" ]; then
    echo "Generating crypto materials..."
    
    # Create crypto-config.yaml
    cat > /tmp/crypto-config.yaml <<EOC
OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    EnableNodeOUs: true
    Specs:
      - Hostname: orderer
        SANS:
          - localhost
          - orderer.example.com

PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    EnableNodeOUs: true
    Template:
      Count: 1
      SANS:
        - localhost
        - peer0.org1.example.com
    Users:
      Count: 1
EOC

    # Generate crypto materials
    cryptogen generate --config=/tmp/crypto-config.yaml --output="/crypto-config"
    
    echo "Crypto materials generated successfully"
else
    echo "Crypto materials already exist"
fi

if [ ! -f "/channel-artifacts/genesis.block" ]; then
    echo "Generating genesis block..."
    
    # Create configtx.yaml
    cat > /tmp/configtx.yaml <<EOC
Organizations:
    - &OrdererOrg
        Name: OrdererOrg
        ID: OrdererMSP
        MSPDir: /crypto-config/ordererOrganizations/example.com/msp
        Policies:
            Readers:
                Type: Signature
                Rule: "OR('OrdererMSP.member')"
            Writers:
                Type: Signature
                Rule: "OR('OrdererMSP.member')"
            Admins:
                Type: Signature
                Rule: "OR('OrdererMSP.admin')"

    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: /crypto-config/peerOrganizations/org1.example.com/msp
        Policies:
            Readers:
                Type: Signature
                Rule: "OR('Org1MSP.admin', 'Org1MSP.peer', 'Org1MSP.client')"
            Writers:
                Type: Signature
                Rule: "OR('Org1MSP.admin', 'Org1MSP.client')"
            Admins:
                Type: Signature
                Rule: "OR('Org1MSP.admin')"
            Endorsement:
                Type: Signature
                Rule: "OR('Org1MSP.peer')"

Capabilities:
    Channel: &ChannelCapabilities
        V2_0: true
    Orderer: &OrdererCapabilities
        V2_0: true
    Application: &ApplicationCapabilities
        V2_0: true

Application: &ApplicationDefaults
    Organizations:
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: "ANY Readers"
        Writers:
            Type: ImplicitMeta
            Rule: "ANY Writers"
        Admins:
            Type: ImplicitMeta
            Rule: "MAJORITY Admins"
        LifecycleEndorsement:
            Type: ImplicitMeta
            Rule: "MAJORITY Endorsement"
        Endorsement:
            Type: ImplicitMeta
            Rule: "MAJORITY Endorsement"
    Capabilities:
        <<: *ApplicationCapabilities

Orderer: &OrdererDefaults
    OrdererType: solo
    Addresses:
        - orderer.example.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB
    Organizations:
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: "ANY Readers"
        Writers:
            Type: ImplicitMeta
            Rule: "ANY Writers"
        Admins:
            Type: ImplicitMeta
            Rule: "MAJORITY Admins"
        BlockValidation:
            Type: ImplicitMeta
            Rule: "ANY Writers"

Channel: &ChannelDefaults
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: "ANY Readers"
        Writers:
            Type: ImplicitMeta
            Rule: "ANY Writers"
        Admins:
            Type: ImplicitMeta
            Rule: "MAJORITY Admins"
    Capabilities:
        <<: *ChannelCapabilities

Profiles:
    OneOrgOrdererGenesis:
        <<: *ChannelDefaults
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
    
    OneOrgChannel:
        Consortium: SampleConsortium
        <<: *ChannelDefaults
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org1
            Capabilities:
                <<: *ApplicationCapabilities
EOC

    # Generate genesis block
    export FABRIC_CFG_PATH=/tmp
    configtxgen -profile OneOrgOrdererGenesis -channelID system-channel -outputBlock /channel-artifacts/genesis.block
    
    # Generate channel configuration
    configtxgen -profile OneOrgChannel -outputCreateChannelTx /channel-artifacts/mychannel.tx -channelID mychannel
    
    echo "Genesis block and channel artifacts generated successfully"
else
    echo "Genesis block already exists"
fi

# Start the application
python3 /app/server.py
EOF

RUN chmod +x /app/scripts/setup-crypto.sh

# Create the Python server
RUN cat > /app/server.py << 'EOF'
#!/usr/bin/env python3
from flask import Flask, jsonify
from datetime import datetime
import subprocess
import json
import threading
import time
import os

app = Flask(__name__)

@app.route('/')
def home():
    return '''
    <html>
    <body style="font-family: Arial; padding: 40px; background: #f5f5f5;">
        <div style="max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <h1>🔗 COBOL Blockchain System</h1>
            <div style="background: #d4edda; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3>✅ Status: Running</h3>
                <p>Container: cobol-metadata-node</p>
                <p>Network: Hyperledger Fabric</p>
            </div>
            <h3>Endpoints:</h3>
            <ul>
                <li><a href="/health">Health Check</a></li>
                <li><a href="/metrics">Metrics</a></li>
                <li><a href="/fabric-status">Fabric Network Status</a></li>
            </ul>
        </div>
    </body>
    </html>
    '''

@app.route('/health')
def health():
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'container': 'cobol-metadata-node',
        'services': {
            'web': 'running',
            'adapter': 'running',
            'fabric-connection': check_fabric_connection()
        }
    })

@app.route('/fabric-status')
def fabric_status():
    return jsonify({
        'peer_endpoint': os.environ.get('FABRIC_PEER_ENDPOINT', 'Not configured'),
        'orderer_endpoint': os.environ.get('FABRIC_ORDERER_ENDPOINT', 'Not configured'),
        'crypto_generated': os.path.exists('/crypto-config/ordererOrganizations'),
        'genesis_block': os.path.exists('/channel-artifacts/genesis.block')
    })

@app.route('/metrics')
def metrics():
    return f"cobol_blockchain_health 1\ncobol_blockchain_uptime_seconds {int(time.time() - start_time)}", 200, {'Content-Type': 'text/plain'}

def check_fabric_connection():
    # Simple check - in real implementation would check peer connectivity
    return 'configured' if os.environ.get('FABRIC_PEER_ENDPOINT') else 'not configured'

def adapter_loop():
    """Background adapter that writes logs"""
    os.makedirs('/app/logs', exist_ok=True)
    while True:
        try:
            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'type': 'heartbeat',
                'status': 'running',
                'fabric_peer': os.environ.get('FABRIC_PEER_ENDPOINT', 'not set')
            }
            with open('/app/logs/adapter.log', 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
            print(f"Adapter heartbeat: {log_entry['timestamp']}")
            time.sleep(30)
        except Exception as e:
            print(f"Adapter error: {e}")
            time.sleep(5)

if __name__ == '__main__':
    start_time = time.time()
    
    # Start adapter in background thread
    adapter_thread = threading.Thread(target=adapter_loop, daemon=True)
    adapter_thread.start()
    
    # Start Flask server
    print("Starting COBOL Blockchain System on port 8080...")
    app.run(host='0.0.0.0', port=8080)
EOF

RUN chmod +x /app/server.py

# Create entrypoint
RUN cat > /app/entrypoint.sh << 'EOF'
#!/bin/bash
# Run setup script which handles crypto generation and starts the server
exec /app/scripts/setup-crypto.sh
EOF

RUN chmod +x /app/entrypoint.sh

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

ENTRYPOINT ["/app/entrypoint.sh"]
EOF