# Fixed Simple Dockerfile
FROM ubuntu:20.04

# Prevent interactive prompts
ENV DEBIAN_FRONTEND=noninteractive
ENV PYTHONUNBUFFERED=1

# Install dependencies
RUN apt-get update && apt-get install -y \
    gnucobol \
    build-essential \
    python3 \
    python3-pip \
    nodejs \
    npm \
    curl \
    wget \
    netcat \
    supervisor \
    && rm -rf /var/lib/apt/lists/*

# Install Python packages
RUN pip3 install flask requests google-cloud-pubsub

# Install Node.js packages
RUN npm install -g express

# Create app structure with proper directory creation
WORKDIR /app
RUN mkdir -p data logs scripts adapters pipes

# Create sample data files
RUN echo "MASTER001 Master Record 1" > data/master.dat && \
    echo "CUST001   John Doe" > data/customer.dat && \
    echo "TXN001    Transaction 1" > data/transaction.dat && \
    echo "ACC001    Account 1" > data/accounts.dat

# Create startup script
RUN cat > start.sh << 'EOF'
#!/bin/bash
echo "Starting COBOL Blockchain System..."

# Ensure directories exist
mkdir -p logs scripts adapters

# Create log files
touch logs/adapter.log logs/system.log logs/fabric-transactions.log logs/blockchain-writes.log

# Create health API
cat > scripts/health.js << 'HEALTH_EOF'
const express = require('express');
const app = express();
app.use(express.json());

app.get('/health', (req, res) => {
    const { exec } = require('child_process');
    
    const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        services: { adapter: 'running', cobol: 'available' },
        fabric: { peer: 'checking', orderer: 'checking' },
        system: { uptime: process.uptime() }
    };
    
    // Test Fabric connectivity
    exec('nc -z peer0.org1.example.com 7051', { timeout: 2000 }, (error) => {
        health.fabric.peer = error ? 'disconnected' : 'connected';
    });
    
    exec('nc -z orderer.example.com 7050', { timeout: 2000 }, (error) => {
        health.fabric.orderer = error ? 'disconnected' : 'connected';
    });
    
    res.json(health);
});

app.get('/', (req, res) => {
    res.send(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>COBOL Blockchain System</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
                .container { max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                .status { padding: 20px; margin: 15px 0; border-radius: 8px; background: #d4edda; border: 1px solid #c3e6cb; }
                .endpoint { margin: 10px 0; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #007bff; }
                h1 { color: #333; margin-bottom: 20px; }
                h2 { color: #555; margin-top: 30px; }
                a { color: #007bff; text-decoration: none; }
                a:hover { text-decoration: underline; }
                .info { color: #666; font-size: 14px; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>🔗 COBOL Blockchain System</h1>
                
                <div class="status">
                    <h3>✅ System Status: Healthy</h3>
                    <p>Enhanced COBOL blockchain container is running</p>
                    <p class="info">Started: ${new Date().toISOString()}</p>
                    <p class="info">Uptime: ${Math.floor(process.uptime())} seconds</p>
                </div>
                
                <h2>📡 API Endpoints</h2>
                <div class="endpoint">
                    <strong>GET /health</strong> - System health check and status
                </div>
                <div class="endpoint">
                    <strong>GET /metrics</strong> - Prometheus metrics for monitoring
                </div>
                <div class="endpoint">
                    <strong>POST /test-message</strong> - Send test message to system
                </div>
                
                <h2>🔗 Quick Actions</h2>
                <ul>
                    <li><a href="/health">Health Check</a> - View system status</li>
                    <li><a href="/metrics">Metrics</a> - View system metrics</li>
                    <li><a href="http://localhost:3000" target="_blank">Grafana Dashboard</a> - Advanced monitoring</li>
                </ul>
                
                <h2>📊 System Information</h2>
                <p><strong>Container:</strong> cobol-metadata-node</p>
                <p><strong>Fabric Channel:</strong> metadata-channel</p>
                <p><strong>Project:</strong> metadata-blockchain</p>
                <p><strong>Architecture:</strong> Local COBOL → Fabric Peer → GCP Peer</p>
            </div>
        </body>
        </html>
    `);
});

app.get('/metrics', (req, res) => {
    const fs = require('fs');
    const metrics = [];
    
    // Basic system metrics
    metrics.push('# HELP cobol_blockchain_health System health status');
    metrics.push('# TYPE cobol_blockchain_health gauge');
    metrics.push('cobol_blockchain_health 1');
    
    metrics.push('# HELP cobol_blockchain_uptime_seconds System uptime in seconds');
    metrics.push('# TYPE cobol_blockchain_uptime_seconds gauge');
    metrics.push(`cobol_blockchain_uptime_seconds ${Math.floor(process.uptime())}`);
    
    // Log file metrics
    try {
        const logFiles = ['adapter.log', 'system.log', 'fabric-transactions.log', 'blockchain-writes.log'];
        logFiles.forEach(logFile => {
            try {
                const stats = fs.statSync(`logs/${logFile}`);
                const fileSize = stats.size;
                const fileName = logFile.replace('.log', '').replace('-', '_');
                
                metrics.push(`# HELP cobol_blockchain_log_size_bytes Size of ${logFile} in bytes`);
                metrics.push(`# TYPE cobol_blockchain_log_size_bytes gauge`);
                metrics.push(`cobol_blockchain_log_size_bytes{file="${fileName}"} ${fileSize}`);
            } catch (e) {
                // File doesn't exist, skip
            }
        });
    } catch (e) {
        // Directory doesn't exist, skip
    }
    
    res.set('Content-Type', 'text/plain');
    res.send(metrics.join('\n'));
});

app.post('/test-message', (req, res) => {
    const fs = require('fs');
    
    const testMessage = {
        id: `TEST_${Date.now()}`,
        entity: 'test',
        operation: 'CREATE',
        data: req.body || { message: 'Health check test' },
        timestamp: new Date().toISOString(),
        source: 'health_api'
    };
    
    try {
        // Log the test message
        const logEntry = {
            timestamp: new Date().toISOString(),
            type: 'test_message',
            data: testMessage,
            status: 'RECEIVED'
        };
        
        fs.appendFileSync('logs/system.log', JSON.stringify(logEntry) + '\n');
        
        res.json({
            success: true,
            message: 'Test message logged successfully',
            data: testMessage
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

const PORT = 8080;
app.listen(PORT, '0.0.0.0', () => {
    console.log(`🚀 COBOL Blockchain Health API listening on port ${PORT}`);
    console.log(`📊 Dashboard available at http://localhost:${PORT}`);
    console.log(`📈 Metrics available at http://localhost:${PORT}/metrics`);
});
HEALTH_EOF

# Create enhanced adapter
cat > adapters/adapter.py << 'ADAPTER_EOF'
#!/usr/bin/env python3
"""
Enhanced Fabric Adapter for COBOL Blockchain System
"""
import json
import time
import logging
import os
import subprocess
from datetime import datetime
from pathlib import Path

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/adapter.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class EnhancedFabricAdapter:
    def __init__(self):
        self.channel = os.getenv('FABRIC_CHANNEL', 'metadata-channel')
        self.chaincode = os.getenv('FABRIC_CHAINCODE', 'metadata-cc')
        self.project_id = os.getenv('GCP_PROJECT_ID', 'metadata-blockchain')
        self.running = True
        
        self.stats = {
            'messages_processed': 0,
            'messages_failed': 0,
            'start_time': datetime.now(),
            'last_activity': None
        }
        
        # Ensure log directory exists
        Path('logs').mkdir(exist_ok=True)
        
        logger.info("Enhanced Fabric Adapter initialized")
        logger.info(f"Channel: {self.channel}, Chaincode: {self.chaincode}")
    
    def check_fabric_connectivity(self):
        """Check if Fabric network is accessible"""
        try:
            # Test peer connectivity
            result = subprocess.run([
                'nc', '-z', 'peer0.org1.example.com', '7051'
            ], capture_output=True, timeout=3)
            
            peer_available = result.returncode == 0
            
            # Test orderer connectivity
            result = subprocess.run([
                'nc', '-z', 'orderer.example.com', '7050'
            ], capture_output=True, timeout=3)
            
            orderer_available = result.returncode == 0
            
            return peer_available and orderer_available
            
        except Exception as e:
            logger.warning(f"Fabric connectivity check failed: {e}")
            return False
    
    def invoke_chaincode(self, metadata):
        """Invoke chaincode with the metadata"""
        try:
            if not self.check_fabric_connectivity():
                logger.warning("Fabric network not available, logging to file")
                return self.log_to_file(metadata)
            
            # Prepare chaincode invocation command
            cmd = [
                'docker', 'exec', 'cli', 'peer', 'chaincode', 'invoke',
                '-o', 'orderer.example.com:7050',
                '-C', self.channel,
                '-n', self.chaincode,
                '-c', json.dumps({
                    "function": "CreateMetadata",
                    "Args": [
                        metadata.get('id', ''),
                        metadata.get('entity', ''),
                        metadata.get('operation', ''),
                        json.dumps(metadata.get('data', {})),
                        metadata.get('timestamp', datetime.now().isoformat())
                    ]
                })
            ]
            
            # Execute chaincode invocation
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                logger.info(f"Successfully invoked chaincode for metadata: {metadata.get('id')}")
                self.log_transaction(metadata, 'SUCCESS', result.stdout)
                return True
            else:
                logger.error(f"Chaincode invocation failed: {result.stderr}")
                self.log_transaction(metadata, 'FAILED', result.stderr)
                return self.log_to_file(metadata)
                
        except Exception as e:
            logger.error(f"Error invoking chaincode: {e}")
            return self.log_to_file(metadata)
    
    def log_to_file(self, metadata):
        """Log metadata to file when blockchain is not available"""
        try:
            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'metadata': metadata,
                'status': 'LOGGED_TO_FILE',
                'reason': 'blockchain_unavailable'
            }
            
            with open('logs/blockchain-writes.log', 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
            
            logger.info(f"Metadata logged to file: {metadata.get('id')}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to log to file: {e}")
            return False
    
    def log_transaction(self, metadata, status, details):
        """Log transaction details"""
        try:
            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'metadata_id': metadata.get('id'),
                'status': status,
                'details': details[:500] if details else '',  # Truncate long details
                'channel': self.channel,
                'chaincode': self.chaincode
            }
            
            with open('logs/fabric-transactions.log', 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
                
        except Exception as e:
            logger.error(f"Failed to log transaction: {e}")
    
    def process_cobol_data(self):
        """Monitor and process COBOL data files"""
        logger.info("Starting COBOL data file monitoring")
        
        # Data files to monitor
        data_files = [
            'data/master.dat',
            'data/customer.dat',
            'data/transaction.dat',
            'data/accounts.dat'
        ]
        
        while self.running:
            try:
                for file_path in data_files:
                    if os.path.exists(file_path):
                        # Check file modification time
                        mod_time = os.path.getmtime(file_path)
                        
                        # Track last modification time
                        attr_name = f'last_mod_{file_path.replace("/", "_")}'
                        
                        if hasattr(self, attr_name):
                            if mod_time > getattr(self, attr_name):
                                self.process_data_file(file_path)
                        
                        setattr(self, attr_name, mod_time)
                
                # Generate periodic heartbeat
                if int(time.time()) % 60 == 0:  # Every minute
                    self.generate_heartbeat()
                
                time.sleep(5)  # Check every 5 seconds
                
            except Exception as e:
                logger.error(f"Error in COBOL data processor: {e}")
                time.sleep(10)
    
    def process_data_file(self, file_path):
        """Process a changed data file"""
        try:
            logger.info(f"Processing changed file: {file_path}")
            
            with open(file_path, 'r') as f:
                lines = f.readlines()
            
            # Process recent lines (new additions)
            for line in lines[-2:]:  # Last 2 lines
                if line.strip():
                    metadata = {
                        'id': f"FILE_{int(time.time())}_{abs(hash(line)) % 10000}",
                        'entity': os.path.basename(file_path).replace('.dat', ''),
                        'operation': 'FILE_UPDATE',
                        'data': {
                            'file': file_path,
                            'content': line.strip(),
                            'source': 'COBOL_FILE_MONITOR',
                            'line_hash': abs(hash(line)) % 10000
                        },
                        'timestamp': datetime.now().isoformat()
                    }
                    
                    if self.invoke_chaincode(metadata):
                        self.stats['messages_processed'] += 1
                    else:
                        self.stats['messages_failed'] += 1
                    
                    self.stats['last_activity'] = datetime.now()
            
        except Exception as e:
            logger.error(f"Error processing file {file_path}: {e}")
    
    def generate_heartbeat(self):
        """Generate a periodic heartbeat message"""
        try:
            heartbeat = {
                'id': f"HEARTBEAT_{int(time.time())}",
                'entity': 'system',
                'operation': 'HEARTBEAT',
                'data': {
                    'uptime': (datetime.now() - self.stats['start_time']).total_seconds(),
                    'messages_processed': self.stats['messages_processed'],
                    'messages_failed': self.stats['messages_failed'],
                    'fabric_connected': self.check_fabric_connectivity()
                },
                'timestamp': datetime.now().isoformat()
            }
            
            self.log_to_file(heartbeat)
            logger.info(f"Heartbeat generated - Processed: {self.stats['messages_processed']}, Failed: {self.stats['messages_failed']}")
            
        except Exception as e:
            logger.error(f"Error generating heartbeat: {e}")
    
    def run(self):
        """Main run loop"""
        logger.info("Starting Enhanced Fabric Adapter")
        
        try:
            # Start data processing
            self.process_cobol_data()
            
        except KeyboardInterrupt:
            logger.info("Received shutdown signal")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
        finally:
            self.running = False
            logger.info("Enhanced Fabric Adapter stopped")

if __name__ == "__main__":
    adapter = EnhancedFabricAdapter()
    adapter.run()
ADAPTER_EOF

# Start services in background
echo "🚀 Starting Health API..."
node scripts/health.js &
HEALTH_PID=$!

echo "🔗 Starting Enhanced Adapter..."
python3 adapters/adapter.py &
ADAPTER_PID=$!

# Store PIDs
echo $HEALTH_PID > logs/health.pid
echo $ADAPTER_PID > logs/adapter.pid

echo "✅ All services started successfully!"
echo "📊 Health API: http://localhost:8080"
echo "📈 Metrics: http://localhost:8080/metrics"

# Keep container running
tail -f /dev/null
EOF

RUN chmod +x start.sh

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

CMD ["./start.sh"]